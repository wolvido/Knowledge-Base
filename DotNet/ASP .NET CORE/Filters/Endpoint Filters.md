Endpoint Filters execute like [[Action Filter]]s, but instead of executing before and after the action method, they execute before and after an endpoint. Mainly used to validate parameters of the endpoint in Minimal API.
![[Pasted image 20240515132503.png]]
###### Syntax:
```c#
app.MapGet("/route", async (HttpContxt context) => {
	//...
}).AddEndpointFilter.async(EndpointFilterInvocationContext context, EndpointFilterDelegate next) => {

	//before MapGet runs
	var result = await next(context);
	//after MapGet runs
	
	return result;
});
```
This syntax runs even inside a [[MapGroups]] class.
# How-To:
For example, Since Minimal API has no built-in validation for now, we want to add validations to the endpoint filters.
So first, in your model, add the attribute validations:
```c#
public class Product
{
    [Required(ErrorMessage="Id is required")] //with required validation
    public int Id { get; set; }
    [Required(ErrorMessage="Product Name is required")] //with required validation
    public string? ProductName { get; set; }
}
```


```c#

app.MapPost("/products", async (HttpContext context, Product product) =>
{
    products.Add(product);
    await context.Response.WriteAsJsonAsync(products);
}).AddEndpointFilter(async (EndpointFilterInvocationContext context, EndpointFilterDelegate next) => {
	//`context` is the http context, `next` is the next delegate, MapPost is the current endpoint delegate.
	
	var product = context.Arguments.OfType<Product>().FirstOrDefault();
		//`context` can access everything, `context.Arguments` access the arguments of MapPost-
		//here we will get the product argument sent to MapPost
	
	if (product == null)
	{
		//if there is no product, then return a 400
		return Results.BadRequest("Product details are not found in the request");
	}
	
	var validationContext = new ValidationContext(product);
		//here we create the validation context, since Min API has no built in validator.
		//this way we can catch the validation errors generated by the validation attributes in product.
	
	List<ValidationResult> errors = new List<ValidationResult>();
		//prepare the variable for storing the errors, this will hold all the errors if exist.
	
	bool isValid = Validator.TryValidateObject(product, validationContext, errors, true);
		//`Validator.TryValidateObject` will validate `product`, store the errors in `errors`,- 
		//and `true` means to validate all properties.
		//isValid will return true if no validation errors found.
	
	if (!isValid)
	{
		//if not valid, then put all the error messages in BadRequest() and return it.
		return Results.BadRequest(errors.FirstOrDefault()?.ErrorMessage);
	}
	
	var result = await next(context); //invokes the next endpoint filter or endpoint delegate.
	
	//After logic here
	//None in this sample, but add whatever you need here maybe modify the return, or logging, or error handling etc..
	
	return result;
});
```
##### ==You can also apply Endpoint filters on the [[MapGroups]] so it applies to the whole MapGroup.==
# What next?
- [[IEndpointFilter]] - Organize your code, create separate [[Endpoint Filters]] into different files, instead of cluttering the endpoints.